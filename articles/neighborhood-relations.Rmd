---
title: "Neighborhood Relations"
output: distill::distill_article
bibliography: bibliography.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(gridabm)
library(GGally)
library(network)
library(sna)
library(igraph)
```

Cellular automata usually operate on lattices and they perform **local computations**, meaning that the state of a cell depends on the cell's immediate vicinity and not some global state.
This means that we need some definitions of what constitutes a neighborhood in cellular automata.
But the concept of neighborhoods extends to agent-based models as well.

### Moore Neighborhood

Perhaps the most common neighborhood relation is the **Moore neighborhood**.
It is used, for instance, in Conway's *life*.

The Moore neighborhood is defined on a two-dimensional lattice, or simply but, a grid.
This is what it looks like:

```{r}
moore <- t(
  matrix(
    c(
      c(0, 0, 0, 0, 0, 0, 0),
      c(0, 0, 0, 0, 0, 0, 0),
      c(0, 0, 1, 1, 1, 0, 0),
      c(0, 0, 1, 2, 1, 0, 0),
      c(0, 0, 1, 1, 1, 0, 0),
      c(0, 0, 0, 0, 0, 0, 0),
      c(0, 0, 0, 0, 0, 0, 0)
    ),
    nrow = 7
  )
)
moore %>% plot_state(17, c(`0` = "white", `1` = "grey80", `2` = "grey20"))
```


The Moore neighborhood is simply given by the four cells on each side of a cell as well as the four cells on each corner of a cell (think north, north-east, east, south-east, etc.).

You might say "Well of course all 8 adjacent cells are the neighborhood of a cell! What else could it be?".
Well, there is one obvious other way.

### Von Neumann Neighborhood

The **Von Neumann neighborhood** is also defined on a lattice (although it is more generic and applies not only to two-dimensional grids, more on that further down).
On a two-dimensional lattice, it's simply the four cells that are adjacent to each side of a cell.

```{r}
vonneumann <- t(
  matrix(
    c(
      c(0, 0, 0, 0, 0, 0, 0),
      c(0, 0, 0, 0, 0, 0, 0),
      c(0, 0, 0, 1, 0, 0, 0),
      c(0, 0, 1, 2, 1, 0, 0),
      c(0, 0, 0, 1, 0, 0, 0),
      c(0, 0, 0, 0, 0, 0, 0),
      c(0, 0, 0, 0, 0, 0, 0)
    ),
    nrow = 7
  )
)
vonneumann %>% plot_state(17, c(`0` = "white", `1` = "grey80", `2` = "grey20"))
```

The more formal definition, however, is that the Von Neumann neighborhood is comprised of the cell in question and all cells within a Manhattan distance of 1.


### Neighborhoods in Graphs

In a graph, the definition for neighborhood is pretty straight-forward.
In the simplest case, it is just all nodes that are connected to a node by an edge.
Of course, you can also define neighborhoods with larger distances, for example all nodes that are within a path distance of 1 of a node.

```{r}
# Graph neighborhood
set.seed(42)
g <- barabasi.game(n = 30, m = 2, start.graph = make_full_graph(5), directed = FALSE)
self <- which(igraph::degree(g) == max(igraph::degree(g)))
df <- igraph::as_data_frame(g)
net <- network(df, directed = FALSE)
self <- which(sna::degree(net) == max(sna::degree(net)))
self_neighborhood <- network::get.neighborhood(net, self)
self_neighborhood_order_2 <- self_neighborhood
for (sn in self_neighborhood) {
  self_neighborhood_order_2 <- c(self_neighborhood_order_2, network::get.neighborhood(net, sn))
}
self_neighborhood_order_2 <- unique(self_neighborhood_order_2)
self_neighborhood_order_2 <- self_neighborhood_order_2[!self_neighborhood_order_2 == self]

self_edges_order_2 <- get.edgeIDs(net, self)
for (sn in self_neighborhood) {
  self_edges_order_2 <- c(self_edges_order_2, get.edgeIDs(net, sn))
}
self_edges_order_2 <- unique(self_edges_order_2)

xy <- gplot.layout.kamadakawai(net, NULL)
net %v% "x" = xy[, 1]
net %v% "y" = xy[, 2]
```

```{r}
net_1 <- net
for (v in seq_along(net$val)) {
  if (v %in% self_neighborhood) {
    net$val[[v]]$v_color <- "coral"
    net$val[[v]]$v_size <- 2
  }
  else if (v == self) {
    net$val[[v]]$v_color <- "firebrick"
    net$val[[v]]$v_size <- 10
  }
  else {
    net$val[[v]]$v_color <- "lightgrey"
    net$val[[v]]$v_size <- 1
  }
}

for (e in valid.eids(net)) {
  if (e %in% get.edgeIDs(net, self)) {
    net$mel[[e]]$atl$e_size <- 1.5
    net$mel[[e]]$atl$e_color <- "coral"
  }
  else {
    net$mel[[e]]$atl$e_size <- 1
    net$mel[[e]]$atl$e_color <- "lightgrey"
  }
}

ggnet2(
  net, 
  mode = c("x", "y"),
  edge.alpha = 0.5,
  color = "v_color",
  node.size = "v_size",
  edge.color = "e_color",
  edge.size = "e_size"
) +
  theme(legend.position = "None")
```


Larger distances work accordingly.
The neighborhood of order 2 contains all the nodes that are at a distance of 2 from a node.

```{r}
for (v in seq_along(net$val)) {
  if (v %in% self_neighborhood_order_2) {
    net$val[[v]]$v_color <- "coral"
    net$val[[v]]$v_size <- 2
  }
  else if (v == self) {
    net$val[[v]]$v_color <- "firebrick"
    net$val[[v]]$v_size <- 10
  }
  else {
    net$val[[v]]$v_color <- "lightgrey"
    net$val[[v]]$v_size <- 1
  }
}

for (e in valid.eids(net)) {
  if (e %in% self_edges_order_2) {
    net$mel[[e]]$atl$e_size <- 1.5
    net$mel[[e]]$atl$e_color <- "coral"
  }
  else {
    net$mel[[e]]$atl$e_size <- 1
    net$mel[[e]]$atl$e_color <- "lightgrey"
  }
}

ggnet2(
  net, 
  mode = c("x", "y"),
  edge.alpha = 0.5,
  color = "v_color",
  node.size = "v_size",
  edge.color = "e_color",
  edge.size = "e_size"
) +
  theme(legend.position = "None")
```










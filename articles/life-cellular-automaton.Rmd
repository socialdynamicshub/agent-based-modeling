---
title: "Conway's Life"
output: distill::distill_article
bibliography: bibliography.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(ggplot2)
library(gganimate)
library(magick)
library(dplyr)
library(tidyr)
source("./helpers/life.R")
source("./helpers/get_moore_neighborhood.R")
source("./helpers/board_to_df.R")
source("./helpers/grid_plot.R")
set.seed(420)
```

```{r notes}
# NOTE: visualization with ggplot currently flips the board
#       -> maybe fix in visualization
```


This game has first been described in a public newsletter by Martin Gardner [@gardner1970mathematical].

Take a square grid of sufficient size and assign each cell one of two states: alive or dead.
Let' start with something small, say 20x20:

```{r}
initial_state <- matrix(sample(c(0, 1), prob = c(0.8, 0.2), replace = TRUE, 400), nrow = 20, ncol = 20)
initial_state_df <- board_to_df(initial_state)
initial_state_df$cell_id <- 1:nrow(initial_state_df)

color_scheme <- c(`0` = "white", `1` = "black")

initial_state_df %>% 
  grid_plot(5, color_scheme)
```

White cells are dead and black cells are alive.

We will now update the automaton one step at a time according to the following rules [@gardner1970mathematical]:

* Survivals: Each alive cell with 2 or 3 neighbors survives into the next generation.
* Deaths: Each alive cell that has less than 2 neighbors dies from isolation. Each alive cell with 4 or more neighbors dies from overpopulation.
* Births: Each dead cell with exactly 3 neighbors becomes alive.

If we talk about neighbors, we are referring to the Moore neighborhood.
Note that we apply these rules to all cells **simultaneously**.

So far so good.
Seems innoccuous, right?

#### Task

What would you expect to happen when we play this setup out over many generations?


In fact, this cellular automaton, called *Life*, displays some very complex dynamics, and, frankly, some really fancy ones.

Let's have a look at how the initial state shown above would play out.

```{r full-game}
game_of_life <- life_game(initial_state, 100)

color_scheme <- c(`0` = "white", `1` = "black")

anim <- game_of_life %>% 
  grid_plot(5, color_scheme) +
  transition_states(step, transition_length = 1, state_length = 10)

animate(anim, nframes = 101, renderer = gifski_renderer())
```

You can see that there are some pulsing things, some moving things, and many more interesting emergent patterns.

To this day, people are hunting for these patterns.
There is already a rich library of regularities and classifications on *Life*, some of which we will have a look at.

### Glider

The **glider** is perhaps the most infamous structure in *life*.

It looks like this:

```{r glider}
axis_size <- 20
initial_state <- matrix(
  nrow = axis_size,
  ncol = axis_size,
  data = rep(0, axis_size^2)
)
initial_state[3, 1] <- 1
initial_state[3, 2] <- 1
initial_state[3, 3] <- 1
initial_state[2, 3] <- 1
initial_state[1, 2] <- 1

game_of_life <- life_game(initial_state, 100)

color_scheme <- c(`0` = "white", `1` = "black")

anim <- game_of_life %>% 
  grid_plot(5, color_scheme) +
  transition_states(step, transition_length = 1, state_length = 10) +
  ggtitle("A Glider in Life")

animate(anim, nframes = 101, renderer = gifski_renderer())
```



TODO:

* gliders and spaceships, oscillators, still lifes
* a bit of history
* intuitive notion of emergence






#### Project

Implement *Life* in Julia.